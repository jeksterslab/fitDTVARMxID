% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fitDTVARMxID-fit-dt-var-mx-id.R
\name{FitDTVARMxID}
\alias{FitDTVARMxID}
\title{Fit the First-Order Discrete-Time Vector Autoregressive Model by ID}
\usage{
FitDTVARMxID(
  data,
  observed,
  id,
  alpha_fixed = TRUE,
  alpha_free = NULL,
  alpha_values = NULL,
  alpha_lbound = NULL,
  alpha_ubound = NULL,
  beta_fixed = FALSE,
  beta_free = NULL,
  beta_values = NULL,
  beta_lbound = NULL,
  beta_ubound = NULL,
  psi_diag = FALSE,
  psi_d_free = NULL,
  psi_d_values = NULL,
  psi_d_lbound = NULL,
  psi_d_ubound = NULL,
  psi_l_free = NULL,
  psi_l_values = NULL,
  psi_l_lbound = NULL,
  psi_l_ubound = NULL,
  nu_fixed = FALSE,
  nu_free = NULL,
  nu_values = NULL,
  nu_lbound = NULL,
  nu_ubound = NULL,
  theta_diag = TRUE,
  theta_fixed = FALSE,
  theta_d_free = NULL,
  theta_d_values = NULL,
  theta_d_lbound = NULL,
  theta_d_ubound = NULL,
  theta_d_equal = FALSE,
  theta_l_free = NULL,
  theta_l_values = NULL,
  theta_l_lbound = NULL,
  theta_l_ubound = NULL,
  mu0_fixed = TRUE,
  mu0_func = FALSE,
  mu0_free = NULL,
  mu0_values = NULL,
  mu0_lbound = NULL,
  mu0_ubound = NULL,
  sigma0_fixed = TRUE,
  sigma0_func = FALSE,
  sigma0_diag = FALSE,
  sigma0_d_free = NULL,
  sigma0_d_values = NULL,
  sigma0_d_lbound = NULL,
  sigma0_d_ubound = NULL,
  sigma0_l_free = NULL,
  sigma0_l_values = NULL,
  sigma0_l_lbound = NULL,
  sigma0_l_ubound = NULL,
  tries_explore = 100,
  tries_local = 10,
  max_attempts = 10,
  grad_tol = 0.01,
  hess_tol = 1e-08,
  eps = 1e-06,
  factor = 10,
  overwrite = FALSE,
  path = getwd(),
  prefix = "FitDTVARMxID",
  seed = 42,
  silent = FALSE,
  ncores = NULL,
  clean = TRUE
)
}
\arguments{
\item{data}{Data frame.
A data frame object of data for potentially
multiple subjects that contain
a column of subject ID numbers
(i.e., an ID variable), and
at least one column of observed values.}

\item{observed}{Character vector.
A vector of character strings
of the names of the observed variables in the data.}

\item{id}{Character string.
A character string of the name of the ID variable in the data.}

\item{alpha_fixed}{Logical.
If \code{TRUE}, the dynamic model intercept vector \code{alpha} is fixed.
If \code{FALSE}, \code{alpha} is estimated.}

\item{alpha_free}{Logical vector indicating which elements of \code{alpha}
are freely estimated. If \code{NULL}, all elements are free.
Ignored if \code{alpha_fixed = TRUE}.}

\item{alpha_values}{Numeric vector of values for \code{alpha}.
If \code{alpha_fixed = TRUE}, these are fixed values.
If \code{alpha_fixed = FALSE}, these are starting values.
If \code{NULL}, defaults to a vector of zeros.}

\item{alpha_lbound}{Numeric vector of lower bounds for \code{alpha}.
If \code{NULL}, no lower bounds are set.
Ignored if \code{alpha_fixed = TRUE}.}

\item{alpha_ubound}{Numeric vector of upper bounds for \code{alpha}.
If \code{NULL}, no upper bounds are set.
Ignored if \code{alpha_fixed = TRUE}.}

\item{beta_fixed}{Logical.
If \code{TRUE}, the dynamic model coefficient matrix \code{beta} is fixed.
If \code{FALSE}, \code{beta} is estimated.}

\item{beta_free}{Logical matrix indicating which elements of \code{beta}
are freely estimated. If \code{NULL}, all elements are free.
Ignored if \code{beta_fixed = TRUE}.}

\item{beta_values}{Numeric matrix of values for \code{beta}.
If \code{beta_fixed = TRUE}, these are fixed values.
If \code{beta_fixed = FALSE}, these are starting values.
If \code{NULL}, defaults to a zero matrix.}

\item{beta_lbound}{Numeric matrix of lower bounds for \code{beta}.
If \code{NULL}, defaults to -1.5.
Ignored if \code{beta_fixed = TRUE}.}

\item{beta_ubound}{Numeric matrix of upper bounds for \code{beta}.
If \code{NULL}, defaults to +1.5.
Ignored if \code{beta_fixed = TRUE}.}

\item{psi_diag}{Logical.
If \code{TRUE}, \code{psi} is diagonal.
If \code{FALSE}, \code{psi} is symmetric.}

\item{psi_d_free}{Logical vector
indicating free/fixed status of the elements of \code{psi_d}.
If \code{NULL}, all element of \code{psi_d} are free.}

\item{psi_d_values}{Numeric vector
with starting values for \code{psi_d}.
If \code{NULL}, defaults to a vector of ones.}

\item{psi_d_lbound}{Numeric vector
with lower bounds for \code{psi_d}.
If \code{NULL}, no lower bounds are set.}

\item{psi_d_ubound}{Numeric vector
with upper bounds for \code{psi_d}.
If \code{NULL}, no upper bounds are set.}

\item{psi_l_free}{Logical matrix
indicating which strictly-lower-triangular elements of \code{psi_l} are free.
Ignored if \code{psi_diag = TRUE}.}

\item{psi_l_values}{Numeric matrix
of starting values for the strictly-lower-triangular elements of \code{psi_l}.
If \code{NULL}, defaults to a null matrix.}

\item{psi_l_lbound}{Numeric matrix
with lower bounds for \code{psi_l}.
If \code{NULL}, no lower bounds are set.}

\item{psi_l_ubound}{Numeric matrix
with upper bounds for \code{psi_l}.
If \code{NULL}, no upper bounds are set.}

\item{nu_fixed}{Logical.
If \code{TRUE}, the measurement model intercept vector \code{nu} is fixed.
If \code{FALSE}, \code{nu} is estimated.}

\item{nu_free}{Logical vector indicating which elements of \code{nu}
are freely estimated. If \code{NULL}, all elements are free.
Ignored if \code{nu_fixed = TRUE}.}

\item{nu_values}{Numeric vector of values for \code{nu}.
If \code{nu_fixed = TRUE}, these are fixed values.
If \code{nu_fixed = FALSE}, these are starting values.
If \code{NULL}, defaults to a vector of zeros.}

\item{nu_lbound}{Numeric vector of lower bounds for \code{nu}.
If \code{NULL}, no lower bounds are set.
Ignored if \code{nu_fixed = TRUE}.}

\item{nu_ubound}{Numeric vector of upper bounds for \code{nu}.
If \code{NULL}, no upper bounds are set.
Ignored if \code{nu_fixed = TRUE}.}

\item{theta_diag}{Logical.
If \code{TRUE}, \code{theta} is diagonal.
If \code{FALSE}, \code{theta} is symmetric.}

\item{theta_fixed}{Logical.
If \code{TRUE}, the measurement error matrix \code{theta}
is fixed to \code{SoftPlus(theta_d_values)}.
If \code{FALSE}, only diagonal elements are estimated
(off-diagonals fixed to zero).}

\item{theta_d_free}{Logical vector
indicating free/fixed status of the diagonal parameters \code{theta_d}.
If \code{NULL}, all element of \code{theta_d} are free.}

\item{theta_d_values}{Numeric vector
with starting values for \code{theta_d}.
If \code{theta_fixed = TRUE}, these are fixed values.
If \code{theta_fixed = FALSE}, these are starting values.
If \code{NULL}, defaults to an identity matrix.}

\item{theta_d_lbound}{Numeric vector
with lower bounds for \code{theta_d}.
If \code{NULL}, no lower bounds are set.}

\item{theta_d_ubound}{Numeric vector
with upper bounds for \code{theta_d}.
If \code{NULL}, no upper bounds are set.}

\item{theta_d_equal}{Logical.
When \code{TRUE}, all free diagonal elements of \code{theta_d} are constrained
to be equal and estimated as a single shared parameter (\code{theta_eq}).
Ignored if no diagonal elements are free.}

\item{theta_l_free}{Logical matrix
indicating which strictly-lower-triangular elements of \code{theta_l} are free.
Ignored if \code{theta_diag = TRUE}.}

\item{theta_l_values}{Numeric matrix
of starting values for the strictly-lower-triangular elements of \code{theta_l}.
If \code{NULL}, defaults to a null matrix.}

\item{theta_l_lbound}{Numeric matrix
with lower bounds for \code{theta_l}.
If \code{NULL}, no lower bounds are set.}

\item{theta_l_ubound}{Numeric matrix
with upper bounds for \code{theta_l}.
If \code{NULL}, no upper bounds are set.}

\item{mu0_fixed}{Logical.
If \code{TRUE}, the initial mean vector \code{mu0} is fixed.
If \code{FALSE}, \code{mu0} is estimated.}

\item{mu0_func}{Logical.
If \code{TRUE} and \code{mu0_fixed = TRUE}, \code{mu0} is fixed to
\eqn{ (I - \beta)^{-1} \alpha }.}

\item{mu0_free}{Logical vector indicating which elements of \code{mu0}
are freely estimated.}

\item{mu0_values}{Numeric vector of values for \code{mu0}.
If \code{mu0_fixed = TRUE}, these are fixed values.
If \code{mu0_fixed = FALSE}, these are starting values.
If \code{NULL}, defaults to a vector of zeros.}

\item{mu0_lbound}{Numeric vector of lower bounds for \code{mu0}.
If \code{NULL}, no lower bounds are set.
Ignored if \code{mu0_fixed = TRUE}.}

\item{mu0_ubound}{Numeric vector of upper bounds for \code{mu0}.
If \code{NULL}, no upper bounds are set.
Ignored if \code{mu0_fixed = TRUE}.}

\item{sigma0_fixed}{Logical.
If \code{TRUE}, the initial covariance matrix \code{sigma0} is fixed.
If \code{FALSE}, \code{sigma0} is estimated.}

\item{sigma0_func}{Logical.
If \code{TRUE} and \code{sigma0_fixed = TRUE}, \code{sigma0} is fixed to
\eqn{ (I - \beta \otimes \beta)^{-1} \mathrm{Vec}(\Psi) }.}

\item{sigma0_diag}{Logical.
If \code{TRUE}, \code{sigma0} is diagonal.
If \code{FALSE}, \code{sigma0} is symmetric.}

\item{sigma0_d_free}{Logical vector
indicating free/fixed status of the elements of \code{sigma0_d}.
If \code{NULL}, all element of \code{sigma0_d} are free.}

\item{sigma0_d_values}{Numeric vector
with starting values for \code{sigma0_d}.
If \code{NULL}, defaults to a vector of ones.}

\item{sigma0_d_lbound}{Numeric vector
with lower bounds for \code{sigma0_d}.
If \code{NULL}, no lower bounds are set.}

\item{sigma0_d_ubound}{Numeric vector
with upper bounds for \code{sigma0_d}.
If \code{NULL}, no upper bounds are set.}

\item{sigma0_l_free}{Logical matrix
indicating which
strictly-lower-triangular elements of \code{sigma0_l} are free.
Ignored if \code{sigma0_diag = TRUE}.}

\item{sigma0_l_values}{Numeric matrix
of starting values
for the strictly-lower-triangular elements of \code{sigma0_l}.
If \code{NULL}, defaults to a null matrix.}

\item{sigma0_l_lbound}{Numeric matrix
with lower bounds for \code{sigma0_l}.
If \code{NULL}, no lower bounds are set.}

\item{sigma0_l_ubound}{Numeric matrix
with upper bounds for \code{sigma0_l}.
If \code{NULL}, no upper bounds are set.}

\item{tries_explore}{Integer.
Number of extra tries for the wide exploration
phase using \code{OpenMx::mxTryHardWideSearch()} with \code{checkHess = FALSE}.}

\item{tries_local}{Integer.
Number of extra tries for local polishing via
\code{OpenMx::mxTryHard()} when gradients remain above tolerance.}

\item{max_attempts}{Integer.
Maximum number of remediation attempts
after the first Hessian computation fails the criteria.
Each attempt may nudge off bounds,
refit locally without the Hessian, and,
on the last attempt, relax bounds.}

\item{grad_tol}{Numeric.
Tolerance for the maximum absolute gradient.
Smaller values are stricter.}

\item{hess_tol}{Numeric.
Minimum allowable Hessian eigenvalue.
Smaller values are less strict.}

\item{eps}{Numeric.
Proximity threshold to detect parameters on their bounds
and to nudge them inward by \code{10 * eps}.}

\item{factor}{Numeric.
Multiplicative factor to relax parameter bounds
on the final remediation attempt.
Lower bounds are divided by \code{factor} and
upper bounds are multiplied by \code{factor}.}

\item{overwrite}{Logical.
If \code{TRUE}, existing intermediate files are overwritten.
Defaults to \code{FALSE}.}

\item{path}{Character string.
Directory in which to save intermediate files.}

\item{prefix}{Alphanumeric character string.
Prefix to use when naming intermediate files.}

\item{seed}{Random seed for reproducibility.}

\item{silent}{Logical.
If \code{TRUE}, suppresses messages during the model fitting stage.}

\item{ncores}{Positive integer.
Number of cores to use.}

\item{clean}{Logical.
If \code{TRUE}, clean intermediate files saved in \code{path}.}
}
\value{
Returns an object of class \code{dtvarmxid} which is
a list with the following elements:
\describe{
\item{call}{Function call.}
\item{args}{List of function arguments.}
\item{fun}{Function used ("FitDTVARMxID").}
\item{output}{A list of fitted OpenMx models.}
}
}
\description{
The function fits
the first-order discrete-time vector autoregressive model
for each unit ID.
}
\details{
The measurement model is given by
\deqn{
  \mathbf{y}_{i, t}
  =
  \boldsymbol{\nu}
  +
  \boldsymbol{\Lambda}
  \boldsymbol{\eta}_{i, t}
  +
  \boldsymbol{\varepsilon}_{i, t},
  \quad
  \mathrm{with}
  \quad
  \boldsymbol{\varepsilon}_{i, t}
  \sim
  \mathcal{N}
  \left(
  \mathbf{0},
  \boldsymbol{\Theta}
  \right)
}
where
\eqn{\mathbf{y}_{i, t}},
\eqn{\boldsymbol{\eta}_{i, t}},
and
\eqn{\boldsymbol{\varepsilon}_{i, t}}
are random variables
and
\eqn{\boldsymbol{\nu}},
\eqn{\boldsymbol{\Lambda}},
and
\eqn{\boldsymbol{\Theta}}
are model parameters.
\eqn{\mathbf{y}_{i, t}}
represents a vector of observed random variables,
\eqn{\boldsymbol{\eta}_{i, t}}
a vector of latent random variables,
and
\eqn{\boldsymbol{\varepsilon}_{i, t}}
a vector of random measurement errors,
at time \eqn{t} and individual \eqn{i}.
\eqn{\boldsymbol{\Lambda}}
denotes a matrix of factor loadings,
and
\eqn{\boldsymbol{\Theta}}
the covariance matrix of
\eqn{\boldsymbol{\varepsilon}}.
In this model,
\eqn{\boldsymbol{\Lambda}} is an identity matrix and
\eqn{\boldsymbol{\Theta}} is a diagonal matrix.

The dynamic structure is given by
\deqn{
  \boldsymbol{\eta}_{i, t}
  =
  \boldsymbol{\alpha}
  +
  \boldsymbol{\beta}
  \boldsymbol{\eta}_{i, t - 1}
  +
  \boldsymbol{\zeta}_{i, t},
  \quad
  \mathrm{with}
  \quad
  \boldsymbol{\zeta}_{i, t}
  \sim
  \mathcal{N}
  \left(
  \mathbf{0},
  \boldsymbol{\Psi}
  \right)
}
where
\eqn{\boldsymbol{\eta}_{i, t}},
\eqn{\boldsymbol{\eta}_{i, t - 1}},
and
\eqn{\boldsymbol{\zeta}_{i, t}}
are random variables,
and
\eqn{\boldsymbol{\alpha}},
\eqn{\boldsymbol{\beta}},
and
\eqn{\boldsymbol{\Psi}}
are model parameters.
Here,
\eqn{\boldsymbol{\eta}_{i, t}}
is a vector of latent variables
at time \eqn{t} and individual \eqn{i},
\eqn{\boldsymbol{\eta}_{i, t - 1}}
represents a vector of latent variables
at time \eqn{t - 1} and individual \eqn{i},
and
\eqn{\boldsymbol{\zeta}_{i, t}}
represents a vector of dynamic noise
at time \eqn{t} and individual \eqn{i}.
\eqn{\boldsymbol{\alpha}}
denotes a vector of intercepts,
\eqn{\boldsymbol{\beta}}
a matrix of autoregression
and cross regression coefficients,
and
\eqn{\boldsymbol{\Psi}}
the covariance matrix of
\eqn{\boldsymbol{\zeta}_{i, t}}.
}
\examples{
\dontrun{
# Generate data using the simStateSpace package------------------------------
set.seed(42)
k <- 2
n <- 5
time <- 100
alpha <- rep(x = 0, times = k)
beta <- matrix(
  data = c(.5, .0, .2, .5),
  nrow = k,
  ncol = k
)
psi <- matrix(
  data = c(exp(-4.1), exp(-3.9), exp(-3.9), exp(-3.2)),
  nrow = k,
  ncol = k
)
psi_l <- t(chol(psi))
nu <- rep(x = 5, times = k)
lambda <- diag(k)
theta <- matrix(
  data = c(exp(-2), 0, 0, exp(-2.8)),
  nrow = k,
  ncol = k
)
theta_l <- t(chol(theta))
mu0 <- c(solve(diag(k) - beta) \%*\% alpha)
sigma0 <- matrix(
  data = c(
    solve(diag(k * k) - beta \%x\% beta) \%*\% c(psi)
  ),
  nrow = k,
  ncol = k
)
sigma0_l <- t(chol(sigma0))
sim <- simStateSpace::SimSSMIVary(
  n = n,
  time,
  mu0 = list(mu0),
  sigma0_l = list(sigma0_l),
  alpha = list(alpha),
  beta = simStateSpace::SimBetaN(
    n = n,
    beta = beta,
    vcov_beta_vec_l = t(chol(0.1 * diag(k * k)))
  ),
  psi_l = list(psi_l),
  nu = list(nu),
  lambda = list(lambda),
  theta_l = list(theta_l)
)
data <- as.data.frame(sim)

# Fit the model--------------------------------------------------------------
library(fitDTVARMxID)
fit <- FitDTVARMxID(
  data = data,
  observed = paste0("y", seq_len(k)),
  id = "id"
)
print(fit)
summary(fit)
coef(fit)
vcov(fit)
converged(fit)
}

}
\references{
Hunter, M. D. (2017).
State space modeling in an open source, modular,
structural equation modeling environment.
\emph{Structural Equation Modeling: A Multidisciplinary Journal},
\emph{25}(2), 307–324.
\doi{10.1080/10705511.2017.1369354}

Neale, M. C., Hunter, M. D., Pritikin, J. N.,
Zahery, M., Brick, T. R., Kirkpatrick, R. M., Estabrook, R.,
Bates, T. C., Maes, H. H., & Boker, S. M. (2015).
OpenMx 2.0: Extended structural equation and statistical modeling.
\emph{Psychometrika},
\emph{81}(2), 535–549.
\doi{10.1007/s11336-014-9435-8}
}
\seealso{
Other DTVAR Functions: 
\code{\link{LDL}()},
\code{\link{Softplus}()}
}
\author{
Ivan Jacob Agaloos Pesigan
}
\concept{DTVAR Functions}
\keyword{fit}
\keyword{fitDTVARMxID}
