---
title: "Fit the Discrete-Time Vector Autoregressive Model By ID (Stable Reciprocal Regulation)"
author: Ivan Jacob Agaloos Pesigan
date: "2025-10-13"
bibliography: "vignettes.bib"
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa.csl
nocite: |
  @RCoreTeam-2024
  @Neale-Hunter-Pritikin-etal-2015
  @Hunter-2017
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Fit the Discrete-Time Vector Autoregressive Model By ID (Stable Reciprocal Regulation)}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---









## Dynamics Description

The *Stable Reciprocal Regulation* process represents a bivariate dynamic system in which two latent psychological constructs---such as positive and negative affect---mutually influence each other over time. Each construct shows moderate self-regulation (autoregressive effects) and mild opposing cross-effects, reflecting an equilibrium-seeking mechanism characteristic of emotional balance.

Individuals vary in their self-regulatory tendencies and in the strength of these antagonistic couplings. At the population level, the transition matrix indicates that increases in one construct are followed by slight decreases in the other, producing a stable, damped oscillatory pattern around individual equilibrium points. The process noise covariance allows for small correlated disturbances, while measurement errors are assumed to be minimal and symmetric across indicators.

This dynamic pattern captures a psychologically plausible process of *reciprocal inhibition*---where short-term fluctuations in one system component (e.g., positive affect) are naturally counteracted by adjustments in its counterpart (e.g., negative affect), leading to emotional homeostasis over time.

## Model

The measurement model is given by
\begin{equation}
  \mathbf{y}_{i, t}
  =
  \boldsymbol{\nu}_{i}
  +
  \boldsymbol{\Lambda}
  \boldsymbol{\eta}_{i, t}
  +
  \boldsymbol{\varepsilon}_{i, t},
  \quad
  \mathrm{with}
  \quad
  \boldsymbol{\varepsilon}_{i, t}
  \sim
  \mathcal{N}
  \left(
  \mathbf{0},
  \boldsymbol{\Theta}_{i}
  \right)
\end{equation}
where
$\mathbf{y}_{i, t}$,
$\boldsymbol{\eta}_{i, t}$,
and
$\boldsymbol{\varepsilon}_{i, t}$
are random variables
and
$\boldsymbol{\nu}_{i}$,
$\boldsymbol{\Lambda}$,
and
$\boldsymbol{\Theta}_{i}$
are model parameters.
$\mathbf{y}_{i, t}$
represents a vector of observed random variables,
$\boldsymbol{\eta}_{i, t}$
a vector of latent random variables,
and
$\boldsymbol{\varepsilon}_{i, t}$
a vector of random measurement errors,
at time $t$ and individual $i$.
$\boldsymbol{\Lambda}$
denotes a matrix of factor loadings,
and
$\boldsymbol{\Theta}_{i}$
the covariance matrix of
$\boldsymbol{\varepsilon}$
for individual $i$.
In this model,
$\boldsymbol{\Lambda}$ is an identity matrix and
$\boldsymbol{\Theta}_{i}$ is a symmetric matrix.

The dynamic structure is given by
\begin{equation}
  \boldsymbol{\eta}_{i, t}
  =
  \boldsymbol{\beta}_{i}
  \boldsymbol{\eta}_{i, t - 1}
  +
  \boldsymbol{\zeta}_{i, t},
  \quad
  \mathrm{with}
  \quad
  \boldsymbol{\zeta}_{i, t}
  \sim
  \mathcal{N}
  \left(
  \mathbf{0},
  \boldsymbol{\Psi}_{i}
  \right)
\end{equation}
where
$\boldsymbol{\eta}_{i, t}$,
$\boldsymbol{\eta}_{i, t - 1}$,
and
$\boldsymbol{\zeta}_{i, t}$
are random variables,
and
$\boldsymbol{\beta}_{i}$,
and
$\boldsymbol{\Psi}_{i}$
are model parameters.
Here,
$\boldsymbol{\eta}_{i, t}$
is a vector of latent variables
at time $t$ and individual $i$,
$\boldsymbol{\eta}_{i, t - 1}$
represents a vector of latent variables
at time $t - 1$ and individual $i$,
and
$\boldsymbol{\zeta}_{i, t}$
represents a vector of dynamic noise
at time $t$ and individual $i$.
$\boldsymbol{\beta}_{i}$ is
a matrix of autoregression
and cross regression coefficients
for individual $i$,
and
$\boldsymbol{\Psi}_{i}$
the covariance matrix of
$\boldsymbol{\zeta}_{i, t}$
for individual $i$.
In this model,
$\boldsymbol{\Psi}_{i}$ is a symmetric matrix.

## Data Generation

### Notation

Let $t = 10100$ be the number of time points and $n = 100$ be the number of individuals.

Let the measurement model intecept vector $\boldsymbol{\nu}$ be normally distributed with the following means

\begin{equation}
\left(
\begin{array}{c}
  0.5 \\
  -0.5 \\
\end{array}
\right)
\end{equation}

and covariance matrix

\begin{equation}
\left(
\begin{array}{cc}
  0.1 & -0.05 \\
  -0.05 & 0.1 \\
\end{array}
\right) .
\end{equation}

Let the factor loadings matrix $\boldsymbol{\Lambda}$ be given by

\begin{equation}
\boldsymbol{\Lambda}
=
\left(
\begin{array}{cc}
  1 & 0 \\
  0 & 1 \\
\end{array}
\right) .
\end{equation}

Let the measurement error covariance matrix $\boldsymbol{\Theta}$ be given by

\begin{equation}
\boldsymbol{\Theta}
=
\left(
\begin{array}{cc}
  0.04 & 0 \\
  0 & 0.04 \\
\end{array}
\right) .
\end{equation}

Let the initial condition
$\boldsymbol{\eta}_{0}$
be given by

\begin{equation}
\boldsymbol{\eta}_{0} \sim \mathcal{N} \left( \boldsymbol{\mu}_{\boldsymbol{\eta} \mid 0}, \boldsymbol{\Sigma}_{\boldsymbol{\eta} \mid 0} \right) .
\end{equation}

$\boldsymbol{\mu}_{\boldsymbol{\eta} \mid 0}$ and $\boldsymbol{\Sigma}_{\boldsymbol{\eta} \mid 0}$ are functions of $\boldsymbol{\alpha}$ and $\boldsymbol{\beta}$.

Let the transition matrix $\boldsymbol{\beta}$ be normally distributed with the following means

\begin{equation}
\left(
\begin{array}{cc}
  0.7 & -0.2 \\
  -0.15 & 0.65 \\
\end{array}
\right)
\end{equation}

and covariance matrix

\begin{equation}
\left(
\begin{array}{cccc}
  0.02 & 0.01 & 0 & 0 \\
  0.01 & 0.015 & 0 & 0 \\
  0 & 0 & 0.01 & 0.005 \\
  0 & 0 & 0.005 & 0.015 \\
\end{array}
\right) .
\end{equation}

Let the intercept vector $\boldsymbol{\alpha}$ be fixed to a zero vector. 

The `SimNuN` and `SimBetaN` functions from the `simStateSpace` package generates random intercept vectors and transition matrices from the multivariate normal distribution. Note that the `SimBetaN` function generates transition matrices that are weakly stationary with an option to set lower and upper bounds.

Let the dynamic process noise $\boldsymbol{\Psi}$ be given by

\begin{equation}
\boldsymbol{\Psi}
=
\left(
\begin{array}{cc}
  0.2 & -0.05 \\
  -0.05 & 0.18 \\
\end{array}
\right) .
\end{equation}




### R Function Arguments


``` r
n
#> [1] 100
time
#> [1] 10100
burnin
#> [1] 10000
# first mu0 in the list of length n
mu0[[1]]
#> [1] 0 0
# first sigma0 in the list of length n
sigma0[[1]]
#>            [,1]       [,2]
#> [1,]  0.3230830 -0.1220195
#> [2,] -0.1220195  0.5527409
# first sigma0_l in the list of length n
sigma0_l[[1]] # sigma0_l <- t(chol(sigma0))
#>            [,1]      [,2]
#> [1,]  0.5684039 0.0000000
#> [2,] -0.2146704 0.7117988
alpha
#> [[1]]
#> [1] 0 0
# first beta in the list of length n
beta[[1]]
#>            [,1]       [,2]
#> [1,]  0.6248343 0.02174497
#> [2,] -0.1054576 0.79427204
# first psi in the list of length n
psi[[1]]
#>       [,1]  [,2]
#> [1,]  0.20 -0.05
#> [2,] -0.05  0.18
psi_l[[1]] # psi_l <- t(chol(psi))
#>            [,1]      [,2]
#> [1,]  0.4472136 0.0000000
#> [2,] -0.1118034 0.4092676
# first nu in the list of length n
nu[[1]]
#> [1]  0.7369682 -0.4934186
lambda
#> [[1]]
#>      [,1] [,2]
#> [1,]    1    0
#> [2,]    0    1
# first theta in the list of length n
theta[[1]]
#>      [,1] [,2]
#> [1,] 0.04 0.00
#> [2,] 0.00 0.04
theta_l[[1]] # theta_l <- t(chol(theta))
#>      [,1] [,2]
#> [1,]  0.2  0.0
#> [2,]  0.0  0.2
```

### Using the `SimSSMIVary` Function from the `simStateSpace` Package to Simulate Data


``` r
library(simStateSpace)
sim <- SimSSMIVary(
  n = n,
  time = time,
  mu0 = mu0,
  sigma0_l = sigma0_l,
  alpha = alpha,
  beta = beta,
  psi_l = psi_l,
  nu = nu,
  lambda = lambda,
  theta_l = theta_l
)
data <- as.data.frame(sim, burnin = burnin)
head(data)
#>   id time        y1         y2
#> 1  1    0 0.3679123 -1.1084155
#> 2  1    1 0.4443673 -1.2596854
#> 3  1    2 0.2801909 -0.2118373
#> 4  1    3 1.0360259 -0.3262629
#> 5  1    4 1.4075254 -1.3072584
#> 6  1    5 0.2984624 -0.3442870
plot(sim, burnin = burnin)
```

<img src="fig-vignettes-stable-reciprical-regulation-unnamed-chunk-7-1.png" width="3300" /><img src="fig-vignettes-stable-reciprical-regulation-unnamed-chunk-7-2.png" width="3300" />

## Model Fitting




``` r
library(fitDTVARMxID)
```

The `FitDTVARMxID` function fits a DT-VAR model on each individual $i$.
To set up the estimation, we first provide **starting values** for each parameter matrix.

### Autoregressive Parameters (`beta`)

The autoregressive coefficient matrix $\boldsymbol{\beta}$ is given starting values.


``` r
beta_values <- beta
```

### Intercepts (`nu`)

The intercept vector $\boldsymbol{\nu}$ is initialized with starting values.


``` r
nu_values <- nu
```

### LDL′-parameterized covariance matrices

Covariances such as `psi` and `theta` are estimated using the LDL′ decomposition of a positive definite covariance matrix. The decomposition expresses a covariance matrix $\Sigma$ as  

\begin{equation}
  \boldsymbol{\Sigma} = \left( \mathbf{L} + \mathbf{I} \right) \mathrm{diag} \left( \mathrm{Softplus} \left( \mathbf{d}_{uc} \right) \right) \left( \mathbf{L} + \mathbf{I} \right)^{\prime},
\end{equation}

where:

- $\mathbf{L}$ is a strictly lower-triangular matrix of free parameters (`l_mat_strict`),  
- $\mathbf{I}$ is the identity matrix,  
- $\mathbf{d}_{uc}$ is an unconstrained vector,  
- $\mathrm{Softplus} \left(\mathbf{d}_{uc} \right) = \log \left(1 + \exp \left( \mathbf{d}_{uc} \right) \right)$ ensures strictly positive diagonal entries.  

The `LDL()` function extracts this decomposition from a positive definite covariance matrix. It returns:  

- `d_uc`: unconstrained diagonal parameters, equal to `InvSoftplus(d_vec)`,  
- `d_vec`: diagonal entries, equal to `Softplus(d_uc)`,  
- `l_mat_strict`: the strictly lower-triangular factor.  


``` r
sigma <- matrix(
  data = c(1.0, 0.5, 0.5, 1.0),
  nrow = 2,
  ncol = 2
)

ldl_sigma <- LDL(sigma)
d_uc <- ldl_sigma$d_uc
l_mat_strict <- ldl_sigma$l_mat_strict
I <- diag(2)
sigma_reconstructed <- (l_mat_strict + I) %*% diag(log1p(exp(d_uc)), 2) %*% t(l_mat_strict + I)
sigma_reconstructed
#>      [,1] [,2]
#> [1,]  1.0  0.5
#> [2,]  0.5  1.0
```

#### Process Noise Covariance Matrix (`psi`)

Starting values for the process noise covariance matrix $\boldsymbol{\Psi}$ are given below, with corresponding LDL′ parameters.


``` r
psi_values <- psi[[1]]
ldl_psi_values <- LDL(psi_values)
psi_d_values <- ldl_psi_values$d_uc
psi_l_values <- ldl_psi_values$l_mat_strict
```


``` r
psi_d_values
#> [1] -1.507772 -1.701853
```


``` r
psi_l_values
#>       [,1] [,2]
#> [1,]  0.00    0
#> [2,] -0.25    0
```

#### Measurement Error Covariance Matrix (`theta`)

Starting values for the measurement error covariance matrix $\boldsymbol{\Theta}$ are given below, with corresponding LDL′ parameters.


``` r
theta_values <- theta[[1]]
ldl_theta_values <- LDL(theta_values)
theta_d_values <- ldl_theta_values$d_uc
```


``` r
theta_d_values
#> [1] -3.198809 -3.198809
```

### Initial mean vector (`mu_0`) and covariance matrix (`sigma_0`)

The initial mean vector $\boldsymbol{\mu_0}$ and covariance matrix $\boldsymbol{\Sigma_0}$
are fixed using `mu0` and `sigma0`.


``` r
mu0_values <- mu0
```


``` r
sigma0_values <- lapply(
  X = sigma0,
  FUN = LDL
)
sigma0_d_values <- lapply(
  X = sigma0_values,
  FUN = function(i) {
    i$d_uc
  }
)
sigma0_l_values <- lapply(
  X = sigma0_values,
  FUN = function(i) {
    i$l_mat_strict
  }
)
```

### `FitDTVARMxID`


``` r
fit <- FitDTVARMxID(
  data = data,
  observed = c("y1", "y2"),
  id = "id",
  beta_values = beta_values,
  psi_d_values = psi_d_values,
  psi_l_values = psi_l_values,
  nu_values = nu_values,
  theta_d_values = theta_d_values,
  theta_d_equal = TRUE,
  mu0_values = mu0_values,
  sigma0_d_values = sigma0_d_values,
  sigma0_l_values = sigma0_l_values,
  ncores = parallel::detectCores()
)
#> Intermediate files will be saved in /home/ibp5092/work/jeksterslab/devel_fitDTVARMxID/vignettes
#> Warning in parallel::mclapply(X = model, FUN = .MxHelperReadRunSave,
#> tries_explore = tries_explore, : scheduled cores 3, 7, 8, 6, 2, 4, 1
#> encountered errors in user code, all values of the jobs will be affected
```

#### Means of parameter estimates


``` r
summary(fit, means = TRUE)
#>   beta_1_1   beta_2_1   beta_1_2   beta_2_2     nu_1_1     nu_2_1  psi_l_2_1 
#>  0.6482783 -0.1853922 -0.1927488  0.6168938  0.4638306 -0.4847460 -0.2445400 
#>  psi_d_1_1  psi_d_2_1 theta_d_eq 
#> -1.6333661 -1.9208184 -8.0000754
```

#### Proportion of converged cases


``` r
converged(fit)
#> [1] 0.74
```

## References


