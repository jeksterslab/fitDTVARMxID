---
title: "Fit the Discrete-Time Vector Autoregressive Model By ID (Stable Reciprocal Regulation | 1000 Measurement Occasions)"
author: Ivan Jacob Agaloos Pesigan
date: "`r Sys.Date()`"
bibliography: "vignettes.bib"
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa.csl
nocite: |
  @RCoreTeam-2024
  @Neale-Hunter-Pritikin-etal-2015
  @Hunter-2017
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Fit the Discrete-Time Vector Autoregressive Model By ID (Stable Reciprocal Regulation | 1000 Measurement Occasions)}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r}
#| include = FALSE
knitr::opts_chunk$set(
  collapse = TRUE,
  fig.path = "fig-vignettes-stable-reciprical-regulation-",
  fig.cap = "",
  fig.width = 11,
  fig.height = 8,
  fig.retina = 2,
  dpi = 300,
  comment = "#>"
)
```

```{r}
#| echo = FALSE
options(scipen = 999)
set.seed(42)
burnin <- 10000
n <- 100
time <- 1000 + burnin
k <- p <- 2
iden <- diag(k)
null_vec <- rep(x = 0, times = k)
nu <- c(
  0.5,
  -0.5
)
lambda <- list(
  iden
)
theta <- list(
  matrix(
    data = c(
      0.50, 0.00,
      0.00, 0.50
    ),
    nrow = p,
    ncol = p
  )
)
theta_l <- list(
  t(chol(theta[[1]]))
)
alpha <- list(
  rep(x = 0, times = k)
)
beta <- matrix(
  data = c(
    0.70, -0.15,
    -0.20, 0.65
  ),
  nrow = p,
  ncol = p
)
psi <- list(
  matrix(
    data = c(
      0.20, -0.05,
      -0.05, 0.18
    ),
    nrow = p,
    ncol = p
  )
)
psi_l <- list(
  t(chol(psi[[1]]))
)
```

```{r}
#| echo = FALSE
library(simStateSpace)
beta_mu <- beta
beta_sigma <- matrix(
  data = c(
    0.020, 0.010, 0.000, 0.000,
    0.010, 0.015, 0.000, 0.000,
    0.000, 0.000, 0.010, 0.005,
    0.000, 0.000, 0.005, 0.015
  ),
  nrow = p * p
)
beta_sigma_l <- t(chol(beta_sigma))
beta <- SimBetaN(
  n = n,
  beta = beta_mu,
  vcov_beta_vec_l = beta_sigma_l,
  margin = 0.95
)
beta_pop <- do.call(
  what = "rbind",
  args = lapply(
    X = SimBetaN(
      n = 5000000,
      beta = beta_mu,
      vcov_beta_vec_l = beta_sigma_l,
      margin = 0.95
    ),
    FUN = c
  )
)
beta_pop_mean <- colMeans(beta_pop)
beta_pop_cov <- cov(beta_pop)
nu_mu <- nu
nu_sigma <- matrix(
  data = c(
    0.10, -0.05,
    -0.05, 0.10
  ),
  nrow = k
)
nu_sigma_l <- t(chol(nu_sigma))
nu <- SimNuN(
  n = n,
  nu = nu_mu,
  vcov_nu_l = nu_sigma_l
)
```

```{r}
#| echo = FALSE
mu0 <- lapply(
  X = beta,
  FUN = simStateSpace::SSMMeanEta,
  alpha = alpha[[1]]
)
sigma0 <- lapply(
  X = beta,
  FUN = simStateSpace::SSMCovEta,
  psi = psi[[1]]
)
sigma0_l <- lapply(
  X = sigma0,
  FUN = function(i) {
    t(chol(i))
  }
)
```

## Dynamics Description

The *Stable Reciprocal Regulation* process represents a bivariate dynamic system in which two latent psychological constructs---such as positive and negative affect---mutually influence each other over time. Each construct shows moderate self-regulation (autoregressive effects) and mild opposing cross-effects, reflecting an equilibrium-seeking mechanism characteristic of emotional balance.

Individuals vary in their self-regulatory tendencies and in the strength of these antagonistic couplings. At the population level, the transition matrix indicates that increases in one construct are followed by slight decreases in the other, producing a stable, damped oscillatory pattern around individual equilibrium points. The process noise covariance allows for small correlated disturbances, while measurement errors are assumed to be minimal and symmetric across indicators.

This dynamic pattern captures a psychologically plausible process of *reciprocal inhibition*---where short-term fluctuations in one system component (e.g., positive affect) are naturally counteracted by adjustments in its counterpart (e.g., negative affect), leading to emotional homeostasis over time.

## Model

The measurement model is given by
\begin{equation}
  \mathbf{y}_{i, t}
  =
  \boldsymbol{\nu}_{i}
  +
  \boldsymbol{\Lambda}
  \boldsymbol{\eta}_{i, t}
  +
  \boldsymbol{\varepsilon}_{i, t},
  \quad
  \mathrm{with}
  \quad
  \boldsymbol{\varepsilon}_{i, t}
  \sim
  \mathcal{N}
  \left(
  \mathbf{0},
  \boldsymbol{\Theta}_{i}
  \right)
\end{equation}
where
$\mathbf{y}_{i, t}$,
$\boldsymbol{\eta}_{i, t}$,
and
$\boldsymbol{\varepsilon}_{i, t}$
are random variables
and
$\boldsymbol{\nu}_{i}$,
$\boldsymbol{\Lambda}$,
and
$\boldsymbol{\Theta}_{i}$
are model parameters.
$\mathbf{y}_{i, t}$
represents a vector of observed random variables,
$\boldsymbol{\eta}_{i, t}$
a vector of latent random variables,
and
$\boldsymbol{\varepsilon}_{i, t}$
a vector of random measurement errors,
at time $t$ and individual $i$.
$\boldsymbol{\Lambda}$
denotes a matrix of factor loadings,
and
$\boldsymbol{\Theta}_{i}$
the covariance matrix of
$\boldsymbol{\varepsilon}$
for individual $i$.
In this model,
$\boldsymbol{\Lambda}$ is an identity matrix and
$\boldsymbol{\Theta}_{i}$ is a symmetric matrix.

The dynamic structure is given by
\begin{equation}
  \boldsymbol{\eta}_{i, t}
  =
  \boldsymbol{\beta}_{i}
  \boldsymbol{\eta}_{i, t - 1}
  +
  \boldsymbol{\zeta}_{i, t},
  \quad
  \mathrm{with}
  \quad
  \boldsymbol{\zeta}_{i, t}
  \sim
  \mathcal{N}
  \left(
  \mathbf{0},
  \boldsymbol{\Psi}_{i}
  \right)
\end{equation}
where
$\boldsymbol{\eta}_{i, t}$,
$\boldsymbol{\eta}_{i, t - 1}$,
and
$\boldsymbol{\zeta}_{i, t}$
are random variables,
and
$\boldsymbol{\beta}_{i}$,
and
$\boldsymbol{\Psi}_{i}$
are model parameters.
Here,
$\boldsymbol{\eta}_{i, t}$
is a vector of latent variables
at time $t$ and individual $i$,
$\boldsymbol{\eta}_{i, t - 1}$
represents a vector of latent variables
at time $t - 1$ and individual $i$,
and
$\boldsymbol{\zeta}_{i, t}$
represents a vector of dynamic noise
at time $t$ and individual $i$.
$\boldsymbol{\beta}_{i}$ is
a matrix of autoregression
and cross regression coefficients
for individual $i$,
and
$\boldsymbol{\Psi}_{i}$
the covariance matrix of
$\boldsymbol{\zeta}_{i, t}$
for individual $i$.
In this model,
$\boldsymbol{\Psi}_{i}$ is a symmetric matrix.

## Data Generation

### Notation

Let $t = `r time`$ be the number of time points and $n = `r n`$ be the number of individuals.

Let the measurement model intecept vector $\boldsymbol{\nu}$ be normally distributed with the following means

\begin{equation}
\left(
\begin{array}{c}
  `r nu_mu[1]` \\
  `r nu_mu[2]` \\
\end{array}
\right)
\end{equation}

and covariance matrix

\begin{equation}
\left(
\begin{array}{cc}
  `r nu_sigma[1, 1]` & `r nu_sigma[1, 2]` \\
  `r nu_sigma[2, 1]` & `r nu_sigma[2, 2]` \\
\end{array}
\right) .
\end{equation}

Let the factor loadings matrix $\boldsymbol{\Lambda}$ be given by

\begin{equation}
\boldsymbol{\Lambda}
=
\left(
\begin{array}{cc}
  `r lambda[[1]][1, 1]` & `r lambda[[1]][1, 2]` \\
  `r lambda[[1]][2, 1]` & `r lambda[[1]][2, 2]` \\
\end{array}
\right) .
\end{equation}

Let the measurement error covariance matrix $\boldsymbol{\Theta}$ be given by

\begin{equation}
\boldsymbol{\Theta}
=
\left(
\begin{array}{cc}
  `r theta[[1]][1, 1]` & `r theta[[1]][1, 2]` \\
  `r theta[[1]][2, 1]` & `r theta[[1]][2, 2]` \\
\end{array}
\right) .
\end{equation}

Let the initial condition
$\boldsymbol{\eta}_{0}$
be given by

\begin{equation}
\boldsymbol{\eta}_{0} \sim \mathcal{N} \left( \boldsymbol{\mu}_{\boldsymbol{\eta} \mid 0}, \boldsymbol{\Sigma}_{\boldsymbol{\eta} \mid 0} \right) .
\end{equation}

$\boldsymbol{\mu}_{\boldsymbol{\eta} \mid 0}$ and $\boldsymbol{\Sigma}_{\boldsymbol{\eta} \mid 0}$ are functions of $\boldsymbol{\alpha}$ and $\boldsymbol{\beta}$.

Let the transition matrix $\boldsymbol{\beta}$ be normally distributed with the following means

\begin{equation}
\left(
\begin{array}{cc}
  `r beta_mu[1, 1]` & `r beta_mu[1, 2]` \\
  `r beta_mu[2, 1]` & `r beta_mu[2, 2]` \\
\end{array}
\right)
\end{equation}

and covariance matrix

\begin{equation}
\left(
\begin{array}{cccc}
  `r beta_sigma[1, 1]` & `r beta_sigma[1, 2]` & `r beta_sigma[1, 3]` & `r beta_sigma[1, 4]` \\
  `r beta_sigma[2, 1]` & `r beta_sigma[2, 2]` & `r beta_sigma[2, 3]` & `r beta_sigma[2, 4]` \\
  `r beta_sigma[3, 1]` & `r beta_sigma[3, 2]` & `r beta_sigma[3, 3]` & `r beta_sigma[3, 4]` \\
  `r beta_sigma[4, 1]` & `r beta_sigma[4, 2]` & `r beta_sigma[4, 3]` & `r beta_sigma[4, 4]` \\
\end{array}
\right) .
\end{equation}

Let the intercept vector $\boldsymbol{\alpha}$ be fixed to a zero vector. 

The `SimNuN` and `SimBetaN` functions from the `simStateSpace` package generates random intercept vectors and transition matrices from the multivariate normal distribution. Note that the `SimBetaN` function generates transition matrices that are weakly stationary with an option to set lower and upper bounds.

Let the dynamic process noise $\boldsymbol{\Psi}$ be given by

\begin{equation}
\boldsymbol{\Psi}
=
\left(
\begin{array}{cc}
  `r psi[[1]][1, 1]` & `r psi[[1]][1, 2]` \\
  `r psi[[1]][2, 1]` & `r psi[[1]][2, 2]` \\
\end{array}
\right) .
\end{equation}


```{r}
#| echo = FALSE
options(scipen = 0)
```

### R Function Arguments

```{r}
n
time
burnin
# first mu0 in the list of length n
mu0[[1]]
# first sigma0 in the list of length n
sigma0[[1]]
# first sigma0_l in the list of length n
sigma0_l[[1]] # sigma0_l <- t(chol(sigma0))
alpha
# first beta in the list of length n
beta[[1]]
# first psi in the list of length n
psi[[1]]
psi_l[[1]] # psi_l <- t(chol(psi))
# first nu in the list of length n
nu[[1]]
lambda
# first theta in the list of length n
theta[[1]]
theta_l[[1]] # theta_l <- t(chol(theta))
```

### Visualizing the Dynamics Without Process Noise and Measurement Error (n = 5 with Different Initial Condition)

```{r no-error}
#| echo = FALSE
library(simStateSpace)
sim <- SimSSMFixed(
  n = 5,
  time = 20,
  mu0 = c(0, 0),
  sigma0_l = diag(2),
  alpha = c(0, 0),
  beta = beta_mu,
  psi_l = matrix(
    data = 0,
    nrow = k,
    ncol = k
  ),
  nu = nu_mu,
  lambda = diag(2),
  theta_l = matrix(
    data = 0,
    nrow = k,
    ncol = k
  ),
  type = 0
)
plot(sim, type = "l")
```

### Using the `SimSSMIVary` Function from the `simStateSpace` Package to Simulate Data

```{r error}
library(simStateSpace)
sim <- SimSSMIVary(
  n = n,
  time = time,
  mu0 = mu0,
  sigma0_l = sigma0_l,
  alpha = alpha,
  beta = beta,
  psi_l = psi_l,
  nu = nu,
  lambda = lambda,
  theta_l = theta_l
)
data <- as.data.frame(sim, burnin = burnin)
head(data)
plot(sim, burnin = burnin)
```

## Model Fitting

```{r}
#| include = FALSE
library(OpenMx)
library(fitDTVARMxID)
```

```{r}
library(OpenMx)
library(fitDTVARMxID)
```

The `FitDTVARMxID` function fits a DT-VAR model on each individual $i$.
To set up the estimation, we first provide **starting values** for each parameter matrix.

### Autoregressive Parameters (`beta`)

The autoregressive coefficient matrix $\boldsymbol{\beta}$ is given starting values.

```{r}
beta_values <- beta
```

### Intercepts (`nu`)

The intercept vector $\boldsymbol{\nu}$ is initialized with starting values.

```{r}
nu_values <- nu
```

### LDL′-parameterized covariance matrices

Covariances such as `psi` and `theta` are estimated using the LDL′ decomposition of a positive definite covariance matrix. The decomposition expresses a covariance matrix $\Sigma$ as  

\begin{equation}
  \boldsymbol{\Sigma} = \left( \mathbf{L} + \mathbf{I} \right) \mathrm{diag} \left( \mathrm{Softplus} \left( \mathbf{d}_{uc} \right) \right) \left( \mathbf{L} + \mathbf{I} \right)^{\prime},
\end{equation}

where:

- $\mathbf{L}$ is a strictly lower-triangular matrix of free parameters (`l_mat_strict`),  
- $\mathbf{I}$ is the identity matrix,  
- $\mathbf{d}_{uc}$ is an unconstrained vector,  
- $\mathrm{Softplus} \left(\mathbf{d}_{uc} \right) = \log \left(1 + \exp \left( \mathbf{d}_{uc} \right) \right)$ ensures strictly positive diagonal entries.  

The `LDL()` function extracts this decomposition from a positive definite covariance matrix. It returns:  

- `d_uc`: unconstrained diagonal parameters, equal to `InvSoftplus(d_vec)`,  
- `d_vec`: diagonal entries, equal to `Softplus(d_uc)`,  
- `l_mat_strict`: the strictly lower-triangular factor.  

```{r}
sigma <- matrix(
  data = c(1.0, 0.5, 0.5, 1.0),
  nrow = 2,
  ncol = 2
)

ldl_sigma <- LDL(sigma)
d_uc <- ldl_sigma$d_uc
l_mat_strict <- ldl_sigma$l_mat_strict
I <- diag(2)
sigma_reconstructed <- (l_mat_strict + I) %*% diag(log1p(exp(d_uc)), 2) %*% t(l_mat_strict + I)
sigma_reconstructed
```

#### Process Noise Covariance Matrix (`psi`)

Starting values for the process noise covariance matrix $\boldsymbol{\Psi}$ are given below, with corresponding LDL′ parameters.

```{r}
psi_values <- psi[[1]]
ldl_psi_values <- LDL(psi_values)
psi_d_values <- ldl_psi_values$d_uc
psi_l_values <- ldl_psi_values$l_mat_strict
```

```{r}
psi_d_values
```

```{r}
psi_l_values
```

#### Measurement Error Covariance Matrix (`theta`)

Starting values for the measurement error covariance matrix $\boldsymbol{\Theta}$ are given below, with corresponding LDL′ parameters.

```{r}
theta_values <- theta[[1]]
ldl_theta_values <- LDL(theta_values)
theta_d_values <- ldl_theta_values$d_uc
theta_l_values <- ldl_theta_values$l_mat_strict
```

```{r}
theta_d_values
```

```{r}
theta_l_values
```

### Initial mean vector (`mu_0`) and covariance matrix (`sigma_0`)

The initial mean vector $\boldsymbol{\mu_0}$ and covariance matrix $\boldsymbol{\Sigma_0}$
are fixed using `mu0` and `sigma0`.

```{r}
mu0_values <- mu0
```

```{r}
sigma0_values <- lapply(
  X = sigma0,
  FUN = LDL
)
sigma0_d_values <- lapply(
  X = sigma0_values,
  FUN = function(i) {
    i$d_uc
  }
)
sigma0_l_values <- lapply(
  X = sigma0_values,
  FUN = function(i) {
    i$l_mat_strict
  }
)
```

### `FitDTVARMxID`

```{r, message = FALSE, warning = FALSE}
fit <- FitDTVARMxID(
  data = data,
  observed = c("y1", "y2"),
  id = "id",
  beta_values = beta_values,
  psi_d_values = psi_d_values,
  psi_l_values = psi_l_values,
  nu_values = nu_values,
  theta_d_values = theta_d_values,
  mu0_values = mu0_values,
  sigma0_d_values = sigma0_d_values,
  sigma0_l_values = sigma0_l_values,
  ncores = parallel::detectCores()
)
```

#### Parameter estimates

```{r}
summary(fit, converged = FALSE)
```

#### Proportion of converged cases

```{r}
converged(
  fit,
  theta_tol = 0.01,
  prop = TRUE
)
```

#### Meta-analyze the measurement error covariance matrix for the converged cases

```{r, message = FALSE, warning = FALSE}
library(metaVAR)
fixed_theta <- MetaVARMx(
  fit,
  random = FALSE,
  effects = FALSE,
  cov_meas = TRUE,
  theta_tol = 0.01
)
```

```{r}
coef(fixed_theta)
summary(fixed_theta)
```

```{r}
theta_d_values <- coef(fixed_theta)
```

#### Refit the model with fixed measurement error covariance matrix

```{r, message = FALSE, warning = FALSE}
fit <- FitDTVARMxID(
  data = data,
  observed = c("y1", "y2"),
  id = "id",
  beta_values = beta_values,
  psi_d_values = psi_d_values,
  psi_l_values = psi_l_values,
  nu_values = nu_values,
  theta_fixed = TRUE,
  theta_d_values = theta_d_values,
  mu0_values = mu0_values,
  sigma0_d_values = sigma0_d_values,
  sigma0_l_values = sigma0_l_values,
  ncores = parallel::detectCores()
)
```

#### Parameter estimates

```{r, message = FALSE, warning = FALSE}
random <- MetaVARMx(
  fit,
  effects = TRUE,
  int_meas = TRUE
)
summary(random)
```

Extract estimated parameters.

```{r}
coefs <- coef(random)
covs <- matrix(
  data = fitDTVARMxID:::.SymofVech(
    x = coefs[7:27],
    k = 6
  ),
  nrow = 6,
  ncol = 6
)
beta_means <- matrix(
  data = coefs[1:4],
  nrow = 2,
  ncol = 2
)
beta_cov <- covs[1:4, 1:4]
nu_means <- coefs[5:6]
nu_cov <- covs[5:6, 5:6]
```

Estimated  values for the transition matrix.

```{r}
beta_means
beta_cov
```

Estimated values for the observed means.

```{r}
nu_means
nu_cov
```

Population values for the transition matrix based on 5 million replications.

```{r}
beta_pop_mean
beta_pop_cov
```

Population values for the observed means.

```{r}
nu_mu
nu_sigma
```

#### Proportion of converged cases

```{r}
converged(
  fit,
  prop = TRUE
)
```

## References

```{r}
#| include = FALSE
rm(list = ls())
```
