---
title: "Fit the Discrete-Time Vector Autoregressive Model By ID (Adaptive Recovery)"
author: Ivan Jacob Agaloos Pesigan
date: "`r Sys.Date()`"
bibliography: "vignettes.bib"
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa.csl
nocite: |
  @RCoreTeam-2024
  @Neale-Hunter-Pritikin-etal-2015
  @Hunter-2017
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Fit the Discrete-Time Vector Autoregressive Model By ID (Adaptive Recovery)}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r}
#| include = FALSE
knitr::opts_chunk$set(
  collapse = TRUE,
  fig.path = "fig-vignettes-adaptive-recovery-",
  fig.cap = "",
  fig.width = 11,
  fig.height = 8,
  fig.retina = 2,
  dpi = 300,
  comment = "#>"
)
```

```{r}
#| echo = FALSE
options(scipen = 999)
set.seed(42)
burnin <- 10000
n <- 100
time <- 100 + burnin
k <- p <- 2
iden <- diag(k)
null_vec <- rep(x = 0, times = k)
nu <- c(
  0.8,
  0.5
)
lambda <- list(
  iden
)
theta <- list(
  matrix(
    data = c(
      0.20, 0.05,
      0.05, 0.20
    ),
    nrow = p,
    ncol = p
  )
)
theta_l <- list(
  t(chol(theta[[1]]))
)
alpha <- list(
  rep(x = 0, times = k)
)
beta <- matrix(
  data = c(
    0.60, 0.25,
    -0.30, 0.70
  ),
  nrow = p,
  ncol = p
)
psi <- list(
  matrix(
    data = c(
      0.25, -0.10,
      -0.10, 0.22
    ),
    nrow = p,
    ncol = p
  )
)
psi_l <- list(
  t(chol(psi[[1]]))
)
```

```{r}
#| echo = FALSE
library(simStateSpace)
beta_mu <- beta
beta_sigma <- matrix(
  data = c(
    0.025, 0.010, 0.000, 0.000,
    0.010, 0.020, 0.000, 0.000,
    0.000, 0.000, 0.020, 0.010,
    0.000, 0.000, 0.010, 0.025
  ),
  nrow = p * p
)
beta_sigma_l <- t(chol(beta_sigma))
beta <- SimBetaN(
  n = n,
  beta = beta_mu,
  vcov_beta_vec_l = beta_sigma_l,
  margin = 0.95
)
nu_mu <- nu
nu_sigma <- matrix(
  data = c(
    0.15, 0.05,
    0.05, 0.10
  ),
  nrow = k
)
nu_sigma_l <- t(chol(nu_sigma))
nu <- SimNuN(
  n = n,
  nu = nu_mu,
  vcov_nu_l = nu_sigma_l
)
```

```{r}
#| echo = FALSE
mu0 <- lapply(
  X = beta,
  FUN = simStateSpace::SSMMeanEta,
  alpha = alpha[[1]]
)
sigma0 <- lapply(
  X = beta,
  FUN = simStateSpace::SSMCovEta,
  psi = psi[[1]]
)
sigma0_l <- lapply(
  X = sigma0,
  FUN = function(i) {
    t(chol(i))
  }
)
```

## Dynamics Description

The *Adaptive Recovery* process reflects an asymmetric regulatory dynamic between two latent constructs---such as stress and coping---where activation in one system initiates a corrective response in the other. Specifically, stress tends to increase coping responses, while coping reduces subsequent stress, producing a negative feedback loop that promotes stability and recovery.

Individuals differ in the strength and balance of these cross-regulatory influences, leading to variability in how quickly they return to equilibrium after disturbances. The process noise covariance is moderate and negatively correlated, representing compensatory fluctuations where increases in stress are often accompanied by decreases in coping, while measurement error variance is small and symmetric across variables.

This configuration captures a psychologically meaningful *stressâ€“response* mechanism, characterized by self-correcting dynamics that stabilize the system over time through coordinated but asymmetric influences.

## Model

The measurement model is given by
\begin{equation}
  \mathbf{y}_{i, t}
  =
  \boldsymbol{\nu}_{i}
  +
  \boldsymbol{\Lambda}
  \boldsymbol{\eta}_{i, t}
  +
  \boldsymbol{\varepsilon}_{i, t},
  \quad
  \mathrm{with}
  \quad
  \boldsymbol{\varepsilon}_{i, t}
  \sim
  \mathcal{N}
  \left(
  \mathbf{0},
  \boldsymbol{\Theta}_{i}
  \right)
\end{equation}
where
$\mathbf{y}_{i, t}$,
$\boldsymbol{\eta}_{i, t}$,
and
$\boldsymbol{\varepsilon}_{i, t}$
are random variables
and
$\boldsymbol{\nu}_{i}$,
$\boldsymbol{\Lambda}$,
and
$\boldsymbol{\Theta}_{i}$
are model parameters.
$\mathbf{y}_{i, t}$
represents a vector of observed random variables,
$\boldsymbol{\eta}_{i, t}$
a vector of latent random variables,
and
$\boldsymbol{\varepsilon}_{i, t}$
a vector of random measurement errors,
at time $t$ and individual $i$.
$\boldsymbol{\Lambda}$
denotes a matrix of factor loadings,
and
$\boldsymbol{\Theta}_{i}$
the covariance matrix of
$\boldsymbol{\varepsilon}$
for individual $i$.
In this model,
$\boldsymbol{\Lambda}$ is an identity matrix and
$\boldsymbol{\Theta}_{i}$ is a symmetric matrix.

The dynamic structure is given by
\begin{equation}
  \boldsymbol{\eta}_{i, t}
  =
  \boldsymbol{\beta}_{i}
  \boldsymbol{\eta}_{i, t - 1}
  +
  \boldsymbol{\zeta}_{i, t},
  \quad
  \mathrm{with}
  \quad
  \boldsymbol{\zeta}_{i, t}
  \sim
  \mathcal{N}
  \left(
  \mathbf{0},
  \boldsymbol{\Psi}_{i}
  \right)
\end{equation}
where
$\boldsymbol{\eta}_{i, t}$,
$\boldsymbol{\eta}_{i, t - 1}$,
and
$\boldsymbol{\zeta}_{i, t}$
are random variables,
and
$\boldsymbol{\beta}_{i}$,
and
$\boldsymbol{\Psi}_{i}$
are model parameters.
Here,
$\boldsymbol{\eta}_{i, t}$
is a vector of latent variables
at time $t$ and individual $i$,
$\boldsymbol{\eta}_{i, t - 1}$
represents a vector of latent variables
at time $t - 1$ and individual $i$,
and
$\boldsymbol{\zeta}_{i, t}$
represents a vector of dynamic noise
at time $t$ and individual $i$.
$\boldsymbol{\beta}_{i}$ is
a matrix of autoregression
and cross regression coefficients
for individual $i$,
and
$\boldsymbol{\Psi}_{i}$
the covariance matrix of
$\boldsymbol{\zeta}_{i, t}$
for individual $i$.
In this model,
$\boldsymbol{\Psi}_{i}$ is a symmetric matrix.

## Data Generation

### Notation

Let $t = `r time`$ be the number of time points and $n = `r n`$ be the number of individuals.

Let the measurement model intecept vector $\boldsymbol{\nu}$ be normally distributed with the following means

\begin{equation}
\left(
\begin{array}{c}
  `r nu_mu[1]` \\
  `r nu_mu[2]` \\
\end{array}
\right)
\end{equation}

and covariance matrix

\begin{equation}
\left(
\begin{array}{cc}
  `r nu_sigma[1, 1]` & `r nu_sigma[1, 2]` \\
  `r nu_sigma[2, 1]` & `r nu_sigma[2, 2]` \\
\end{array}
\right) .
\end{equation}

Let the factor loadings matrix $\boldsymbol{\Lambda}$ be given by

\begin{equation}
\boldsymbol{\Lambda}
=
\left(
\begin{array}{cc}
  `r lambda[[1]][1, 1]` & `r lambda[[1]][1, 2]` \\
  `r lambda[[1]][2, 1]` & `r lambda[[1]][2, 2]` \\
\end{array}
\right) .
\end{equation}

Let the measurement error covariance matrix $\boldsymbol{\Theta}$ be given by

\begin{equation}
\boldsymbol{\Theta}
=
\left(
\begin{array}{cc}
  `r theta[[1]][1, 1]` & `r theta[[1]][1, 2]` \\
  `r theta[[1]][2, 1]` & `r theta[[1]][2, 2]` \\
\end{array}
\right) .
\end{equation}

Let the initial condition
$\boldsymbol{\eta}_{0}$
be given by

\begin{equation}
\boldsymbol{\eta}_{0} \sim \mathcal{N} \left( \boldsymbol{\mu}_{\boldsymbol{\eta} \mid 0}, \boldsymbol{\Sigma}_{\boldsymbol{\eta} \mid 0} \right) .
\end{equation}

$\boldsymbol{\mu}_{\boldsymbol{\eta} \mid 0}$ and $\boldsymbol{\Sigma}_{\boldsymbol{\eta} \mid 0}$ are functions of $\boldsymbol{\alpha}$ and $\boldsymbol{\beta}$.

Let the transition matrix $\boldsymbol{\beta}$ be normally distributed with the following means

\begin{equation}
\left(
\begin{array}{cc}
  `r beta_mu[1, 1]` & `r beta_mu[1, 2]` \\
  `r beta_mu[2, 1]` & `r beta_mu[2, 2]` \\
\end{array}
\right)
\end{equation}

and covariance matrix

\begin{equation}
\left(
\begin{array}{cccc}
  `r beta_sigma[1, 1]` & `r beta_sigma[1, 2]` & `r beta_sigma[1, 3]` & `r beta_sigma[1, 4]` \\
  `r beta_sigma[2, 1]` & `r beta_sigma[2, 2]` & `r beta_sigma[2, 3]` & `r beta_sigma[2, 4]` \\
  `r beta_sigma[3, 1]` & `r beta_sigma[3, 2]` & `r beta_sigma[3, 3]` & `r beta_sigma[3, 4]` \\
  `r beta_sigma[4, 1]` & `r beta_sigma[4, 2]` & `r beta_sigma[4, 3]` & `r beta_sigma[4, 4]` \\
\end{array}
\right) .
\end{equation}

Let the intercept vector $\boldsymbol{\alpha}$ be fixed to a zero vector. 

The `SimNuN` and `SimBetaN` functions from the `simStateSpace` package generates random intercept vectors and transition matrices from the multivariate normal distribution. Note that the `SimBetaN` function generates transition matrices that are weakly stationary with an option to set lower and upper bounds.

Let the dynamic process noise $\boldsymbol{\Psi}$ be given by

\begin{equation}
\boldsymbol{\Psi}
=
\left(
\begin{array}{cc}
  `r psi[[1]][1, 1]` & `r psi[[1]][1, 2]` \\
  `r psi[[1]][2, 1]` & `r psi[[1]][2, 2]` \\
\end{array}
\right) .
\end{equation}


```{r}
#| echo = FALSE
options(scipen = 0)
```

### R Function Arguments

```{r}
n
time
burnin
# first mu0 in the list of length n
mu0[[1]]
# first sigma0 in the list of length n
sigma0[[1]]
# first sigma0_l in the list of length n
sigma0_l[[1]] # sigma0_l <- t(chol(sigma0))
alpha
# first beta in the list of length n
beta[[1]]
# first psi in the list of length n
psi[[1]]
psi_l[[1]] # psi_l <- t(chol(psi))
# first nu in the list of length n
nu[[1]]
lambda
# first theta in the list of length n
theta[[1]]
theta_l[[1]] # theta_l <- t(chol(theta))
```

### Visualizing the Dynamics Without Process Noise and Measurement Error (n = 5 with Different Initial Condition)

```{r no-error}
#| echo = FALSE
library(simStateSpace)
sim <- SimSSMFixed(
  n = 5,
  time = 20,
  mu0 = c(0, 0),
  sigma0_l = diag(2),
  alpha = c(0, 0),
  beta = beta_mu,
  psi_l = matrix(
    data = 0,
    nrow = k,
    ncol = k
  ),
  nu = nu_mu,
  lambda = diag(2),
  theta_l = matrix(
    data = 0,
    nrow = k,
    ncol = k
  ),
  type = 0
)
plot(sim, type = "l")
```

### Using the `SimSSMIVary` Function from the `simStateSpace` Package to Simulate Data

```{r error}
library(simStateSpace)
sim <- SimSSMIVary(
  n = n,
  time = time,
  mu0 = mu0,
  sigma0_l = sigma0_l,
  alpha = alpha,
  beta = beta,
  psi_l = psi_l,
  nu = nu,
  lambda = lambda,
  theta_l = theta_l
)
data <- as.data.frame(sim, burnin = burnin)
head(data)
plot(sim, burnin = burnin)
```

## Model Fitting

```{r}
#| include = FALSE
library(fitDTVARMxID)
```

```{r}
library(fitDTVARMxID)
```

The `FitDTVARMxID` function fits a DT-VAR model on each individual $i$.
To set up the estimation, we first provide **starting values** for each parameter matrix.

### Autoregressive Parameters (`beta`)

The autoregressive coefficient matrix $\boldsymbol{\beta}$ is given starting values.

```{r}
beta_values <- beta
```

### Intercepts (`nu`)

The intercept vector $\boldsymbol{\nu}$ is initialized with starting values.

```{r}
nu_values <- nu
```

### LDLâ€²-parameterized covariance matrices

Covariances such as `psi` and `theta` are estimated using the LDLâ€² decomposition of a positive definite covariance matrix. The decomposition expresses a covariance matrix $\Sigma$ as  

\begin{equation}
  \boldsymbol{\Sigma} = \left( \mathbf{L} + \mathbf{I} \right) \mathrm{diag} \left( \mathrm{Softplus} \left( \mathbf{d}_{uc} \right) \right) \left( \mathbf{L} + \mathbf{I} \right)^{\prime},
\end{equation}

where:

- $\mathbf{L}$ is a strictly lower-triangular matrix of free parameters (`l_mat_strict`),  
- $\mathbf{I}$ is the identity matrix,  
- $\mathbf{d}_{uc}$ is an unconstrained vector,  
- $\mathrm{Softplus} \left(\mathbf{d}_{uc} \right) = \log \left(1 + \exp \left( \mathbf{d}_{uc} \right) \right)$ ensures strictly positive diagonal entries.  

The `LDL()` function extracts this decomposition from a positive definite covariance matrix. It returns:  

- `d_uc`: unconstrained diagonal parameters, equal to `InvSoftplus(d_vec)`,  
- `d_vec`: diagonal entries, equal to `Softplus(d_uc)`,  
- `l_mat_strict`: the strictly lower-triangular factor.  

```{r}
sigma <- matrix(
  data = c(1.0, 0.5, 0.5, 1.0),
  nrow = 2,
  ncol = 2
)

ldl_sigma <- LDL(sigma)
d_uc <- ldl_sigma$d_uc
l_mat_strict <- ldl_sigma$l_mat_strict
I <- diag(2)
sigma_reconstructed <- (l_mat_strict + I) %*% diag(log1p(exp(d_uc)), 2) %*% t(l_mat_strict + I)
sigma_reconstructed
```

#### Process Noise Covariance Matrix (`psi`)

Starting values for the process noise covariance matrix $\boldsymbol{\Psi}$ are given below, with corresponding LDLâ€² parameters.

```{r}
psi_values <- psi[[1]]
ldl_psi_values <- LDL(psi_values)
psi_d_values <- ldl_psi_values$d_uc
psi_l_values <- ldl_psi_values$l_mat_strict
```

```{r}
psi_d_values
```

```{r}
psi_l_values
```

#### Measurement Error Covariance Matrix (`theta`)

Starting values for the measurement error covariance matrix $\boldsymbol{\Theta}$ are given below, with corresponding LDLâ€² parameters.

```{r}
theta_values <- theta[[1]]
ldl_theta_values <- LDL(theta_values)
theta_d_values <- ldl_theta_values$d_uc
```

```{r}
theta_d_values
```

```{r}
theta_l_values <- ldl_theta_values$l_mat_strict
```

### Initial mean vector (`mu_0`) and covariance matrix (`sigma_0`)

The initial mean vector $\boldsymbol{\mu_0}$ and covariance matrix $\boldsymbol{\Sigma_0}$
are fixed using `mu0` and `sigma0`.

```{r}
mu0_values <- mu0
```

```{r}
sigma0_values <- lapply(
  X = sigma0,
  FUN = LDL
)
sigma0_d_values <- lapply(
  X = sigma0_values,
  FUN = function(i) {
    i$d_uc
  }
)
sigma0_l_values <- lapply(
  X = sigma0_values,
  FUN = function(i) {
    i$l_mat_strict
  }
)
```

### `FitDTVARMxID`

```{r}
fit <- FitDTVARMxID(
  data = data,
  observed = c("y1", "y2"),
  id = "id",
  beta_values = beta_values,
  psi_d_values = psi_d_values,
  psi_l_values = psi_l_values,
  nu_values = nu_values,
  theta_diag = FALSE,
  theta_d_values = theta_d_values,
  theta_l_values = theta_l_values,
  mu0_values = mu0_values,
  sigma0_d_values = sigma0_d_values,
  sigma0_l_values = sigma0_l_values,
  prefix = "recovery",
  quiet = TRUE,
  ncores = parallel::detectCores()
)
```

#### Parameter estimates

```{r}
summary(fit)
```

#### Proportion of converged cases

```{r}
converged(fit, prop = TRUE)
```

## References

```{r}
#| include = FALSE
rm(list = ls())
```
